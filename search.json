[{"title":"React组件生命周期","url":"/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"旧版本组件生命周期\n每次执行更新时，shouldComponentUpdate 都会返回一个布尔值\n如果是true (默认)，则继续往下执行\n如果是false ，则停止更新\nshouldComponentUpdate 方法除非开发者自定义，否则默认返回true\n\ncomponentWillReceiveProps 并不会在第一次收到props就执行，而是从第二次开始算起\n.buttonVisited&#123;    background-color: red;    color: white;&#125;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Benz extends React.Component&#123;        componentWillReceiveProps(props)&#123;            console.log(props);            console.log(&#x27;CarBenz-----ComponentWillReceiveProps&#x27;, props);        &#125;        render()&#123;            return(                &lt;div&gt;                    &lt;h2&gt;我是奔驰,我收到了消息：&#123;this.props.carName&#125;&lt;/h2&gt;                &lt;/div&gt;            )        &#125;    &#125;    class BMW extends React.Component&#123;        state = &#123;carName: &#x27;奥迪&#x27;&#125;        changeCar = () =&gt; &#123;            document.querySelector(&#x27;#btn&#x27;).className = &#x27;buttonVisited&#x27;            this.setState(&#123;carName: &#x27;我不是奥迪，我是宝马&#x27;&#125;)        &#125;        render()&#123;            return(                &lt;div&gt;                    &lt;h2&gt;我是宝马&lt;/h2&gt;                    &lt;button onClick= &#123;this.changeCar&#125;&gt;传递&lt;/button&gt;                    &lt;Benz carName=&#123;this.state.carName&#125;/&gt;                &lt;/div&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;BMW /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n在这个程序中，ReactDOM渲染了BMW，而Benz在BMW的render方法中调用，并传递了props\n在BMW中初始化了state，定义了一个changeCar方法来改变state\nBenz中自定义了componentWillReceiveProps方法，并接收了props ，如果接收到，会有输出\n第一次打开页面：\n\n第一次打开并没有触发componentWillReceiveProps\n点击按钮：\n\ncomponentWillReceiveProps触发了！说明它确实是在第二次开始才会触发！\n新版本组件生命周期\n完整图React生命周期-官网\n\n","categories":["计算机","React"]},{"title":"对传入组件的props进行限制","url":"/%E5%AF%B9%E4%BC%A0%E5%85%A5%E7%BB%84%E4%BB%B6%E7%9A%84props%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6/","content":"yarn add prop-types\n\n先添加这个包\n如果在App组件内向子组件传递了props，可以在子组件中对这个props进行限制：\n//App.jsx&lt;Child sayHello=&#123;this.sayHello&#125;/&gt;//Child.jsximport PropsTypes from &#x27;prop-types&#x27; //导入static propTypes = &#123;  sayHello: PropTypes.func.isRequired //限制这个props必须是函数，而且必须传递&#125;\n\n下面是官方给出的propTypes说明：\nMyComponent.propTypes = &#123;  // 你可以将属性声明为 JS 原生类型，默认情况下  // 这些属性都是可选的。  optionalArray: PropTypes.array,  optionalBool: PropTypes.bool,  optionalFunc: PropTypes.func,  optionalNumber: PropTypes.number,  optionalObject: PropTypes.object,  optionalString: PropTypes.string,  optionalSymbol: PropTypes.symbol,  // 任何可被渲染的元素（包括数字、字符串、元素或数组）  // (或 Fragment) 也包含这些类型。  optionalNode: PropTypes.node,  // 一个 React 元素。  optionalElement: PropTypes.element,  // 一个 React 元素类型（即，MyComponent）。  optionalElementType: PropTypes.elementType,  // 你也可以声明 prop 为类的实例，这里使用  // JS 的 instanceof 操作符。  optionalMessage: PropTypes.instanceOf(Message),  // 你可以让你的 prop 只能是特定的值，指定它为  // 枚举类型。  optionalEnum: PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]),  // 一个对象可以是几种类型中的任意一个类型  optionalUnion: PropTypes.oneOfType([    PropTypes.string,    PropTypes.number,    PropTypes.instanceOf(Message)  ]),  // 可以指定一个数组由某一类型的元素组成  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  // 可以指定一个对象由某一类型的值组成  optionalObjectOf: PropTypes.objectOf(PropTypes.number),  // 可以指定一个对象由特定的类型值组成  optionalObjectWithShape: PropTypes.shape(&#123;    color: PropTypes.string,    fontSize: PropTypes.number  &#125;),  // An object with warnings on extra properties  optionalObjectWithStrictShape: PropTypes.exact(&#123;    name: PropTypes.string,    quantity: PropTypes.number  &#125;),  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保  // 这个 prop 没有被提供时，会打印警告信息。  requiredFunc: PropTypes.func.isRequired,  // 任意类型的必需数据  requiredAny: PropTypes.any.isRequired,  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。  // 请不要使用 `console.warn` 或抛出异常，因为这在 `oneOfType` 中不会起作用。  customProp: function(props, propName, componentName) &#123;    if (!/matchme/.test(props[propName])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;,  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。  // 它应该在验证失败时返回一个 Error 对象。  // 验证器将验证数组或对象中的每个值。验证器的前两个参数  // 第一个是数组或对象本身  // 第二个是他们当前的键。  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;    if (!/matchme/.test(propValue[key])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propFullName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;)&#125;;\n\n使用 PropTypes 进行类型检查 - React\n","categories":["计算机","React"]},{"title":"数组方法","url":"/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"filter()接收一个回调函数，返回一个新数组，新数组中包含达到条件的元素\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.filter(item =&gt; item &gt; 10) //大于10的数，都会被放到新数组中console.log(newArr)\n\n结果：\n\nreduce()元素中的每个元素都会参与reduce参数中的回调函数的运算\n传入一个回调函数，回调函数的第一个参数是上一次回调函数执行的结果，第二个参数是目前的数组元素。(可选)传入的第二个参数作为第一次执行回调函数时，回调函数的第一个参数。\n如果第二个参数没有指定，则回调函数的第一个参数会使用数组的第一个元素，第二个参数会使用数组的第二个元素\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.reduce(  (previous,current) =&gt; previous + current,  0)console.log(newArr)\n\nreducer逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果相加（上一步的计算结果是当前元素之前所有元素的总和）——直到没有更多的元素被相加\n结果：\n\nreduce测试题[1,2,3,4].reduce((x,y) =&gt; console.log(x,y))\n\n思考：上面的代码会输出什么？\nmap()方法创建一个新数组，其结果是该数组中的每个元素是调用一次回调函数后的返回值。\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.map((item) =&gt; item+=1)console.log(arr)console.log(newArr)\n\n使用map遍历数组，把每个元素 +1 ，组成新数组\n看结果：\n\n","categories":["计算机","JavaScript"]},{"title":"高阶函数_函数的柯里化","url":"/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96/","content":"高阶函数_函数的柯里化\n💡 高阶函数：如果一个函数符合下列两个规范中的任何一个，就是高阶函数\n                  1. 若A函数，接收的参数是一个函数，那么A就是高阶函数\n                  2. 若A函数，调用后的返回值依然是一个函数，那么A就是高阶函数\n函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码方式\n\n\n\n这里使用了上一个表单案例：\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Login extends React.Component &#123;        //初始化状态        state = &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;,        &#125;        //保存表单数据到状态中        saveFormData = (dataType) =&gt; &#123;            return (e) =&gt; &#123;                this.setState(&#123;[dataType]: e.target.value&#125;)            &#125;        &#125;        //表单提交的回调        handleSubmit = (e) =&gt; &#123;            e.preventDefault()            const &#123; username, password &#125; = this.state            alert(`你输入的用户名是：$&#123;username&#125;，你输出的密码是：$&#123;password&#125;`)        &#125;        render() &#123;            // console.log(this);               return (                &lt;form action=&quot;#&quot; onSubmit=&#123;this.handleSubmit&#125; &gt;                    用户名：&lt;input onChange=&#123;this.saveFormData(&#x27;username&#x27;)&#125; type=&quot;text&quot; name=&quot;username&quot; /&gt;                    密码：&lt;input onChange=&#123;this.saveFormData(&#x27;password&#x27;)&#125; type=&quot;password&quot; name=&quot;password&quot; /&gt;                    &lt;button &gt;登录&lt;/button&gt;                &lt;/form&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;Login /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n通过对比发现，对函数作了精简\nonChange调用的函数变成了同一个函数，不管表单需要输入多少数据，都调用一个函数来处理；调用函数时，同时传递一个参数来标明，获取到的数据类型\n通过前面的多个例子，我们发现了一个现象，在标签内调用函数时，如果加了() ，则程序会出问题，因为加了() 后，程序在一开始就会调用这个函数，onChange 就失去了效果\n那么这里为什么能使用() 传递参数呢？\n因为onChange 触发的需要是一个函数，而这里加了() 后，则变成了一个函数返回值，自然就除了BUG\n所以我们可以让里面的函数返回一个函数，那么onChange 就可以正常工作了！\n这里的saveFormData  就是一个高阶函数！\n不用柯里化的实现上面的例子，不用柯里化怎么实现呢？\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Login extends React.Component &#123;        //初始化状态        state = &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;,        &#125;        //保存表单数据到状态中        saveFormData = (dataType, e) =&gt; &#123;            this.setState(&#123; [dataType]: e.target.value&#125;)        &#125;        //表单提交的回调        handleSubmit = (e) =&gt; &#123;            e.preventDefault()            const &#123; username, password &#125; = this.state            alert(`你输入的用户名是：$&#123;username&#125;，你输出的密码是：$&#123;password&#125;`)        &#125;        render() &#123;            // console.log(this);               return (                &lt;form action=&quot;#&quot; onSubmit=&#123;this.handleSubmit&#125; &gt;                    用户名：&lt;input onChange=&#123;e =&gt; this.saveFormData(&#x27;username&#x27;, e) &#125; type=&quot;text&quot; name=&quot;username&quot; /&gt;                    密码：&lt;input onChange=&#123;e =&gt; this.saveFormData(&#x27;password&#x27;, e) &#125; type=&quot;password&quot; name=&quot;password&quot; /&gt;                    &lt;button &gt;登录&lt;/button&gt;                &lt;/form&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;Login /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n由于onChange 只能接收函数，那我们就给他函数\n里面直接用箭头函数写；写箭头函数时，参数只有一个？括号省略！函数体只有一条语句？大括号省略！\n在这之前把saveFormData这个函数的返回值去掉，改成直接修改状态state \n我们用箭头函数直接调用saveFormData 这个函数，传进两个参数：1. 数据类型标识 2.标签值\n最后实现的功能和上次的一样！\n","categories":["计算机","React"]}]