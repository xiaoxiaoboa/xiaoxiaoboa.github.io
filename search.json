[{"title":"对传入组件的props进行限制","url":"/%E5%AF%B9%E4%BC%A0%E5%85%A5%E7%BB%84%E4%BB%B6%E7%9A%84props%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6/","content":"yarn add prop-types\n\n先添加这个包\n如果在App组件内向子组件传递了props，可以在子组件中对这个props进行限制：\n//App.jsx&lt;Child sayHello=&#123;this.sayHello&#125;/&gt;//Child.jsximport PropsTypes from &#x27;prop-types&#x27; //导入static propTypes = &#123;  sayHello: PropTypes.func.isRequired //限制这个props必须是函数，而且必须传递&#125;\n\n下面是官方给出的propTypes说明：\nMyComponent.propTypes = &#123;  // 你可以将属性声明为 JS 原生类型，默认情况下  // 这些属性都是可选的。  optionalArray: PropTypes.array,  optionalBool: PropTypes.bool,  optionalFunc: PropTypes.func,  optionalNumber: PropTypes.number,  optionalObject: PropTypes.object,  optionalString: PropTypes.string,  optionalSymbol: PropTypes.symbol,  // 任何可被渲染的元素（包括数字、字符串、元素或数组）  // (或 Fragment) 也包含这些类型。  optionalNode: PropTypes.node,  // 一个 React 元素。  optionalElement: PropTypes.element,  // 一个 React 元素类型（即，MyComponent）。  optionalElementType: PropTypes.elementType,  // 你也可以声明 prop 为类的实例，这里使用  // JS 的 instanceof 操作符。  optionalMessage: PropTypes.instanceOf(Message),  // 你可以让你的 prop 只能是特定的值，指定它为  // 枚举类型。  optionalEnum: PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]),  // 一个对象可以是几种类型中的任意一个类型  optionalUnion: PropTypes.oneOfType([    PropTypes.string,    PropTypes.number,    PropTypes.instanceOf(Message)  ]),  // 可以指定一个数组由某一类型的元素组成  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  // 可以指定一个对象由某一类型的值组成  optionalObjectOf: PropTypes.objectOf(PropTypes.number),  // 可以指定一个对象由特定的类型值组成  optionalObjectWithShape: PropTypes.shape(&#123;    color: PropTypes.string,    fontSize: PropTypes.number  &#125;),  // An object with warnings on extra properties  optionalObjectWithStrictShape: PropTypes.exact(&#123;    name: PropTypes.string,    quantity: PropTypes.number  &#125;),  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保  // 这个 prop 没有被提供时，会打印警告信息。  requiredFunc: PropTypes.func.isRequired,  // 任意类型的必需数据  requiredAny: PropTypes.any.isRequired,  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。  // 请不要使用 `console.warn` 或抛出异常，因为这在 `oneOfType` 中不会起作用。  customProp: function(props, propName, componentName) &#123;    if (!/matchme/.test(props[propName])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;,  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。  // 它应该在验证失败时返回一个 Error 对象。  // 验证器将验证数组或对象中的每个值。验证器的前两个参数  // 第一个是数组或对象本身  // 第二个是他们当前的键。  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;    if (!/matchme/.test(propValue[key])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propFullName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;)&#125;;\n\n使用 PropTypes 进行类型检查 - React\n","categories":["计算机","React"]},{"title":"数组方法","url":"/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"filter()接收一个回调函数，返回一个新数组，新数组中包含达到条件的元素\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.filter(item =&gt; item &gt; 10) //大于10的数，都会被放到新数组中console.log(newArr)\n\n结果：\n\nreduce()元素中的每个元素都会参与reduce参数中的回调函数的运算\n传入一个回调函数，回调函数的第一个参数是上一次回调函数执行的结果，第二个参数是目前的数组元素。(可选)传入的第二个参数作为第一次执行回调函数时，回调函数的第一个参数。\n如果第二个参数没有指定，则回调函数的第一个参数会使用数组的第一个元素，第二个参数会使用数组的第二个元素\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.reduce(  (previous,current) =&gt; previous + current,  0)console.log(newArr)\n\nreducer逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果相加（上一步的计算结果是当前元素之前所有元素的总和）——直到没有更多的元素被相加\n结果：\n\nreduce测试题[1,2,3,4].reduce((x,y) =&gt; console.log(x,y))\n\n思考：上面的代码会输出什么？\nmap()方法创建一个新数组，其结果是该数组中的每个元素是调用一次回调函数后的返回值。\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.map((item) =&gt; item+=1)console.log(arr)console.log(newArr)\n\n使用map遍历数组，把每个元素 +1 ，组成新数组\n看结果：\n\n","categories":["计算机","JavaScript"]},{"title":"React组件生命周期","url":"/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"旧版本组件生命周期\n每次执行更新时，shouldComponentUpdate 都会返回一个布尔值\n如果是true (默认)，则继续往下执行\n如果是false ，则停止更新\nshouldComponentUpdate 方法除非开发者自定义，否则默认返回true\n\ncomponentWillReceiveProps 并不会在第一次收到props就执行，而是从第二次开始算起\n.buttonVisited&#123;    background-color: red;    color: white;&#125;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Benz extends React.Component&#123;        componentWillReceiveProps(props)&#123;            console.log(props);            console.log(&#x27;CarBenz-----ComponentWillReceiveProps&#x27;, props);        &#125;        render()&#123;            return(                &lt;div&gt;                    &lt;h2&gt;我是奔驰,我收到了消息：&#123;this.props.carName&#125;&lt;/h2&gt;                &lt;/div&gt;            )        &#125;    &#125;    class BMW extends React.Component&#123;        state = &#123;carName: &#x27;奥迪&#x27;&#125;        changeCar = () =&gt; &#123;            document.querySelector(&#x27;#btn&#x27;).className = &#x27;buttonVisited&#x27;            this.setState(&#123;carName: &#x27;我不是奥迪，我是宝马&#x27;&#125;)        &#125;        render()&#123;            return(                &lt;div&gt;                    &lt;h2&gt;我是宝马&lt;/h2&gt;                    &lt;button onClick= &#123;this.changeCar&#125;&gt;传递&lt;/button&gt;                    &lt;Benz carName=&#123;this.state.carName&#125;/&gt;                &lt;/div&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;BMW /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n在这个程序中，ReactDOM渲染了BMW，而Benz在BMW的render方法中调用，并传递了props\n在BMW中初始化了state，定义了一个changeCar方法来改变state\nBenz中自定义了componentWillReceiveProps方法，并接收了props ，如果接收到，会有输出\n第一次打开页面：\n\n第一次打开并没有触发componentWillReceiveProps\n点击按钮：\n\ncomponentWillReceiveProps触发了！说明它确实是在第二次开始才会触发！\n新版本组件生命周期\n完整图React生命周期-官网\n\n","categories":["计算机","React"]},{"title":"高阶函数_函数的柯里化","url":"/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96/","content":"高阶函数_函数的柯里化\n💡 高阶函数：如果一个函数符合下列两个规范中的任何一个，就是高阶函数\n                  1. 若A函数，接收的参数是一个函数，那么A就是高阶函数\n                  2. 若A函数，调用后的返回值依然是一个函数，那么A就是高阶函数\n函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码方式\n\n\n\n这里使用了上一个表单案例：\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Login extends React.Component &#123;        //初始化状态        state = &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;,        &#125;        //保存表单数据到状态中        saveFormData = (dataType) =&gt; &#123;            return (e) =&gt; &#123;                this.setState(&#123;[dataType]: e.target.value&#125;)            &#125;        &#125;        //表单提交的回调        handleSubmit = (e) =&gt; &#123;            e.preventDefault()            const &#123; username, password &#125; = this.state            alert(`你输入的用户名是：$&#123;username&#125;，你输出的密码是：$&#123;password&#125;`)        &#125;        render() &#123;            // console.log(this);               return (                &lt;form action=&quot;#&quot; onSubmit=&#123;this.handleSubmit&#125; &gt;                    用户名：&lt;input onChange=&#123;this.saveFormData(&#x27;username&#x27;)&#125; type=&quot;text&quot; name=&quot;username&quot; /&gt;                    密码：&lt;input onChange=&#123;this.saveFormData(&#x27;password&#x27;)&#125; type=&quot;password&quot; name=&quot;password&quot; /&gt;                    &lt;button &gt;登录&lt;/button&gt;                &lt;/form&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;Login /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n通过对比发现，对函数作了精简\nonChange调用的函数变成了同一个函数，不管表单需要输入多少数据，都调用一个函数来处理；调用函数时，同时传递一个参数来标明，获取到的数据类型\n通过前面的多个例子，我们发现了一个现象，在标签内调用函数时，如果加了() ，则程序会出问题，因为加了() 后，程序在一开始就会调用这个函数，onChange 就失去了效果\n那么这里为什么能使用() 传递参数呢？\n因为onChange 触发的需要是一个函数，而这里加了() 后，则变成了一个函数返回值，自然就除了BUG\n所以我们可以让里面的函数返回一个函数，那么onChange 就可以正常工作了！\n这里的saveFormData  就是一个高阶函数！\n不用柯里化的实现上面的例子，不用柯里化怎么实现呢？\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Login extends React.Component &#123;        //初始化状态        state = &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;,        &#125;        //保存表单数据到状态中        saveFormData = (dataType, e) =&gt; &#123;            this.setState(&#123; [dataType]: e.target.value&#125;)        &#125;        //表单提交的回调        handleSubmit = (e) =&gt; &#123;            e.preventDefault()            const &#123; username, password &#125; = this.state            alert(`你输入的用户名是：$&#123;username&#125;，你输出的密码是：$&#123;password&#125;`)        &#125;        render() &#123;            // console.log(this);               return (                &lt;form action=&quot;#&quot; onSubmit=&#123;this.handleSubmit&#125; &gt;                    用户名：&lt;input onChange=&#123;e =&gt; this.saveFormData(&#x27;username&#x27;, e) &#125; type=&quot;text&quot; name=&quot;username&quot; /&gt;                    密码：&lt;input onChange=&#123;e =&gt; this.saveFormData(&#x27;password&#x27;, e) &#125; type=&quot;password&quot; name=&quot;password&quot; /&gt;                    &lt;button &gt;登录&lt;/button&gt;                &lt;/form&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;Login /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n由于onChange 只能接收函数，那我们就给他函数\n里面直接用箭头函数写；写箭头函数时，参数只有一个？括号省略！函数体只有一条语句？大括号省略！\n在这之前把saveFormData这个函数的返回值去掉，改成直接修改状态state \n我们用箭头函数直接调用saveFormData 这个函数，传进两个参数：1. 数据类型标识 2.标签值\n最后实现的功能和上次的一样！\n","categories":["计算机","React"]},{"title":"todo案例","url":"/todo%E6%A1%88%E4%BE%8B/","content":"本案例来自B站尚硅谷React课程-张天禹\n使用vite+react搭建脚手架\n在src中建立components文件夹，存放子组件和组件样式；各个子组件使用各自单独的文件夹\n初始化\n在App.jsx中初始化state，\nstate = &#123;todos:[  &#123;id:1,name:&#x27;吃饭&#x27;, done:true&#125;,  &#123;id:2,name:&#x27;睡觉&#x27;, done:false&#125;,  &#123;id:3,name:&#x27;写代码&#x27;, done:false&#125;]&#125;\n\n在render中使用解构赋值，拿到state中的todos；通过props传递给List组件\n List使用解构赋值接收props的值，拿到的是一个数组\n 在render中使用数组的map()方法遍历，每次返回一个，其中key使用todos中组值的ID；同时使用展开语法把todos中的每一组值都通过props传递过去\nconst &#123;todos&#125; = this.state //初始化state&lt;List todos=&#123;todos&#125;/&gt; // 传递给List组件const &#123; todos &#125; = this.props; //List组件从props中接收return (    //在render方法中使用map()  &lt;ul className=&quot;list-box&quot;&gt;    &#123;todos.map((todoObj) =&gt; &#123;      return &lt;Item key=&#123;todoObj.id&#125; &#123;...todoObj&#125;/&gt;; //使用展开语法传递每个todo项    &#125;)&#125;  &lt;/ul&gt;);\n\n 这时页面上已经初始化完成：\n\n\n\nHeader组件：【输入待办】功能因为核心state在App中，所以遵循 state在哪里，操作state的方法就在那里\n\n在App组件中创建addToDo方法，用来操作state；通过props传递给Header组件，Header组件内在input元素上绑定onKeyUp事件，此事件调用一个Header组件实例对象的方法handleKeyUp,用来处理输入事件\n\n每个todo项都有一个id字段，这个字段不能重复；所以用到了一个ID字符生成器：Nano ID\n//App.jsx组件//添加一个todoaddToDo = (todoObj) =&gt; &#123;  //获取state  const &#123; todos &#125; = this.state  //拿到todo对象后，跟原来的todos合并  const newToDos = [todoObj,...todos]  //更新state  this.setState(&#123;todos:newToDos&#125;)&#125;&lt;Header addToDo=&#123;this.addToDo&#125; /&gt; //传递props//Header.jsx组件//输入待办事件handleKeyUp = (e) =&gt; &#123;  //拿到App的传值  const &#123; addToDo &#125; = this.props;  const &#123;target, keyCode&#125; = e  //按下的不是回车键或者输入框为空则返回  if(keyCode !== 13 || target.value.trim() === &#x27;&#x27;) return  //生成唯一ID  const toDoId = nanoid()  //组成新的对象  const newToDo = &#123;id:toDoId,name:target.value,done:false&#125;  //传递给App组件  addToDo(newToDo)  //输入框置空  target.value = &#x27;&#x27;&#125;onKeyUp=&#123;this.handleKeyUp&#125; //键盘事件\n\n \n\n\nItem组件：【完成todo项目】\n在App.jsx组件内创建checkToDo方法，是属于App实例对象的方法；通过props中传递给List组件，然后在List组件内传递给Item组件\n//App.jsx组件//勾选todocheckToDo = (id,done) =&gt; &#123;  const &#123; todos &#125; = this.state  const newToDos = todos.map(todoObj =&gt; &#123;    if(todoObj.id === id) return &#123;...todoObj,done&#125;    else return todoObj  &#125;)  this.setState(&#123;todos:newToDos&#125;)&#125;&lt;List todos=&#123;todos&#125; checkToDo=&#123;this.checkToDo&#125;/&gt; //通过props传递//List组件return (  &lt;ul className=&quot;list-box&quot;&gt;    &#123;todos.map((todoObj) =&gt; &#123;      return &lt;Item key=&#123;todoObj.id&#125; &#123;...todoObj&#125; checkToDo=&#123;checkToDo&#125; /&gt;    &#125;)&#125;  &lt;/ul&gt;);\n\n在Item.jsx组件中创建handleCheckToDo方法，方法属于Item组件实例对象；方法内通过props接收到App传过来的checkToDo方法，来执行\n 还需要在input元素上绑定事件onChange\n//Item组件//处理勾选todohandleCheckToDo = (id) =&gt; &#123;  const &#123; checkToDo &#125; = this.props;  return (e) =&gt; &#123;    const &#123; checked &#125; = e.target;    checkToDo(id, checked);  &#125;;&#125;;//绑定事件&lt;input  type=&quot;checkbox&quot;  checked=&#123;done&#125;  onChange=&#123;this.handleCheckToDo(id)&#125;/&gt;\n\n 运行时报错了\n\n 后来发现绑定事件写错了🤣\n\n 最后效果是：勾选一个tudo时，state里的数据也会随之改变\n \n\n\nItem组件：【删除一个todo】\n在App组件内创建deleteToDo方法，此方法属于App组件实例对象；方法中使用数组的filter方法，过滤出没有被删除的todo，组成新数组；通过props传递此方法给List组件，接着List组件传递给Item组件\n Item组件中创建handleDelete方法，此方法属于Item组件实例对象；通过给按钮添加点击事件来执行此函数，同时要传递一个id\n//App组件deleteToDo = (id) =&gt; &#123;  //拿到state中的todos  const &#123; todos &#125; = this.state;  //使用数组的filter方法，过滤出没有被删除的todo，组成新数组  const newToDos = todos.filter((todoObj) =&gt; &#123;    return todoObj.id !== id;  &#125;);  //更新state  this.setState(&#123;todos: newToDos&#125;)&#125;;//Item组件//删除一个todohandleDelete = (id) =&gt; &#123;  //从props中拿到deleteToDo  const &#123; deleteToDo &#125; = this.props;  return () =&gt; &#123;    //执行并传递要删除的todo的id    deleteToDo(id);  &#125;;&#125;;//通过点击事件来执行&lt;button className=&quot;btn&quot; onClick=&#123;this.handleDelete(id)&#125;&gt; \n\n \n\n\nFooter组件：【全选和计数】\n在App组件中创建checkAllToDo方法，此方法属于App组件实例对象；方法接收一个done参数，标志是否勾选；利用数组的map方法，把这个done的值合并进每个todo对象中\n 把checkAllToDo方法传递给Footer组件，同时把state中的todos也传递过去\n//App组件//勾选全部todocheckAllToDo = (done) =&gt; &#123;  //拿到state中的todos  const &#123; todos &#125; = this.state;  //使用map遍历数组，并把done的值合并进todo对象  const newToDos = todos.map((todoObj) =&gt; &#123;    return &#123; ...todoObj, done &#125;;  &#125;);  //更新state  this.setState(&#123;todos: newToDos&#125;)&#125;;//传递给Footer组件&lt;Footer checkAllToDo=&#123;this.checkAllToDo&#125; todos=&#123;todos&#125; /&gt;\n\n在Footer组件中，通过props接收checkAllToDo；创建handleCheckAll方法，接收一个参数，参数是input的checked；在input上绑定onChange事件来调用handleCheckAll\n//Footer组件const &#123; todos &#125; = this.props; //接收todos//全选handleCheckAll = (e) =&gt; &#123;  //从props中拿到checkAllToDo  const &#123; checkAllToDo &#125; = this.props;  const &#123; checked &#125; = e.target;  //执行checkAllToDo并传递checked  checkAllToDo(checked);&#125;;//绑定onChange事件&lt;input  className=&quot;checkbox&quot;  type=&quot;checkbox&quot;  onChange=&#123;this.handleCheckAll&#125;  checked=&#123;countDone === allToDo &amp;&amp; countDone !== 0 ? true : false&#125;/&gt;\n\n通过props接收todos；全部todo的数量就是todos数组的长度；已完成todo的数量使用数组的reduce方法遍历数组，todo.done为true则是已完成，countDone结果就加上一\n 当然，全选按钮和计数功能是相辅相成的；当全选时，计数中完成的数量就要等于全部todo的数量；当计数全部为0时，也就是没有了todo项，则全选按钮不应该被选中\n 所以全选按钮的checked属性需要做判断来赋值；当countDone和allToDo相等并且countDone不等于0时，则全选按钮被选中，反之不被选中\n//Footer组件const &#123; todos &#125; = this.props;//已完成的todoconst countDone = todos.reduce(  (previous, todo) =&gt; previous + (todo.done ? 1 : 0),  0);//全部todoconst allToDo = todos.length;//checked属性值的判断checked=&#123;countDone === allToDo &amp;&amp; countDone !== 0 ? true : false&#125;\n\n \n\n\nFooter组件：【清除全部已完成项】\n在App组件中创建deleteAllDone方法，此方法属于App组件实例对象；deleteAllDone中先拿到state中的todos，然后使用数组方法filter，过滤出done值为false的todo项，并生成新数组；如果新数组的长度和todos的长度一致，则表明没有已完成项，就return；否则更新state\n 通过props传递给Footer组件\n//App组件//删除全部已完成deleteAllDone = () =&gt; &#123;  //拿到todos  const &#123; todos &#125; = this.state;  //过滤出done值为false的todo项  const newToDos = todos.filter((todoObj) =&gt; !todoObj.done);  if(newToDos.length === todos.length) return  //更新state  this.setState(&#123;todos: newToDos&#125;)&#125;;//传递&lt;Footer  checkAllToDo=&#123;this.checkAllToDo&#125;  todos=&#123;todos&#125;  deleteAllDone=&#123;this.deleteAllDone&#125;/&gt;\n\nFooter组件中在button上绑定点击事件，触发handDeleteAllDone方法；该方法属于Footer实例对象；handDeleteAllDone触发从props中接收到的方法deleteAllDone\n//Footer组件//删除全部已完成handDeleteAllDone = () =&gt; &#123;  const &#123; deleteAllDone &#125; = this.props;  if(window.confirm(&#x27;确定要删除全部已完成的项目么？&#x27;))&#123;    deleteAllDone();  &#125;&#125;;//绑定事件&lt;button className=&quot;btn-clear&quot; onClick=&#123;this.handDeleteAllDone&#125;&gt;\n\n \n\n\n😎todo案例完成 \n本案例来自B站尚硅谷React课程-张天禹\n","categories":["计算机","React"]},{"title":"No license field","url":"/No-license-field/","content":"在使用yarn时，每次执行命令都会有这个警告！很烦！\nwarning package.json: No license field\n\n找到windows用户文件夹内的package.json ，打开添加：&quot;private&quot;: true 字段，表明你并不需要发布这个包\nok！\n","categories":["计算机","yarn"]},{"title":"网络请求的返回结果","url":"/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/","content":"const axios = require(&#x27;axios&#x27;)axios.get(&#x27;http://localhost:8000/posts&#x27;).then(  response =&gt; &#123;    console.log(response)  &#125;,  error =&gt; &#123;    console.log(error.message)  &#125;)\n\n先看请求成功的返回结果：\n\n这只是一部分，下面还有…\n再看错误的：\n\n下面还有好多！\n这种情况，我们根本不能一眼看到想要的正确&#x2F;错误的信息\n所以取回结果的时候要这么写：\nconst axios = require(&#x27;axios&#x27;)axios.get(&#x27;http://localhost:8000/posts&#x27;).then(  response =&gt; &#123;    console.log(response.data)  &#125;,  error =&gt; &#123;    console.log(error.message)  &#125;)\n\n正确的消息数据保存在data里，错误的消息数据保存在message里\n看结果：\n\n\n","categories":["计算机","axios"]}]