[{"title":"No license field","url":"/No-license-field/","content":"在使用yarn时，每次执行命令都会有这个警告！很烦！\nwarning package.json: No license field\n\n找到windows用户文件夹内的package.json ，打开添加：&quot;private&quot;: true 字段，表明你并不需要发布这个包\nok！\n","categories":["计算机","yarn"]},{"title":"React组件生命周期","url":"/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"旧版本组件生命周期\n每次执行更新时，shouldComponentUpdate 都会返回一个布尔值\n如果是true (默认)，则继续往下执行\n如果是false ，则停止更新\nshouldComponentUpdate 方法除非开发者自定义，否则默认返回true\n\ncomponentWillReceiveProps 并不会在第一次收到props就执行，而是从第二次开始算起\n.buttonVisited&#123;    background-color: red;    color: white;&#125;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Benz extends React.Component&#123;        componentWillReceiveProps(props)&#123;            console.log(props);            console.log(&#x27;CarBenz-----ComponentWillReceiveProps&#x27;, props);        &#125;        render()&#123;            return(                &lt;div&gt;                    &lt;h2&gt;我是奔驰,我收到了消息：&#123;this.props.carName&#125;&lt;/h2&gt;                &lt;/div&gt;            )        &#125;    &#125;    class BMW extends React.Component&#123;        state = &#123;carName: &#x27;奥迪&#x27;&#125;        changeCar = () =&gt; &#123;            document.querySelector(&#x27;#btn&#x27;).className = &#x27;buttonVisited&#x27;            this.setState(&#123;carName: &#x27;我不是奥迪，我是宝马&#x27;&#125;)        &#125;        render()&#123;            return(                &lt;div&gt;                    &lt;h2&gt;我是宝马&lt;/h2&gt;                    &lt;button onClick= &#123;this.changeCar&#125;&gt;传递&lt;/button&gt;                    &lt;Benz carName=&#123;this.state.carName&#125;/&gt;                &lt;/div&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;BMW /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n在这个程序中，ReactDOM渲染了BMW，而Benz在BMW的render方法中调用，并传递了props\n在BMW中初始化了state，定义了一个changeCar方法来改变state\nBenz中自定义了componentWillReceiveProps方法，并接收了props ，如果接收到，会有输出\n第一次打开页面：\n\n第一次打开并没有触发componentWillReceiveProps\n点击按钮：\n\ncomponentWillReceiveProps触发了！说明它确实是在第二次开始才会触发！\n新版本组件生命周期\n完整图React生命周期-官网\n\n","categories":["计算机","React"]},{"title":"React路由-NavLink的二次封装","url":"/React%E8%B7%AF%E7%94%B1-NavLink%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/","content":"由于NavLink组件在使用时，可能会有多次调用的情况，那样的话就会写很多重复性代码，所以需要把它二次封装\n重复太多：\n&lt;NavLink activeClassName=&quot;test&quot; className=&quot;nav&quot; to=&quot;/home&quot;&gt;  Home&lt;/NavLink&gt;&lt;NavLink activeClassName=&quot;test&quot; className=&quot;nav&quot; to=&quot;/about&quot;&gt;  About&lt;/NavLink&gt;&lt;NavLink activeClassName=&quot;test&quot; className=&quot;nav&quot; to=&quot;/other&quot;&gt;  Other&lt;/NavLink&gt;\n\n二次封装创建组件MyNavLink，引入基础react组件和react-router-dom组件中的NavLink\nrender里返回一个NavLink标签即可\n&lt;NavLink activeClassName=&quot;test&quot; className=&quot;nav&quot;  &#123;...this.props&#125; /&gt;\n\n调用二次封装后的MyNavLink组件\n&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;\n\nNavLink怎么不是双标签了? 那个展开语法props是干嘛的？\nMyNavLink组件怎么是双标签？标签体中间写了值？组件还能这么用?\n\n首先，在NavLink中：activeClassName、className这些属性可以写死，但是to属性却不行\n所以to属性的值必须在调用时传递过来，当然还有渲染到页面上的链接的名字，也就是双标签之间的内容，都需要通过props；这就是为什么上面用到了展开语法拿到props中的值了；展开语法可以拿到对象中的所有值，所以不管传递了多少属性和值，接收时只需要一个展开语法就可以完美接收全部\n\nprops中怎么能接到链接的名字呢？调用时没有传递这个props啊？\n看下面的代码：\n我创建了Test组件，使用双标签的形式在App组件中调用，在标签体中写入了一段文本，并且传入了一个a参数\n在Test组件中，输出了props\n//App.jsx&lt;Test a=&#123;&quot;我是通过props传递的a属性的值&quot;&#125;&gt;我是Test组件&lt;/Test&gt;//Test.jsxconsole.log(this.props)\n\n请看输出了什么？\n\n输出了一个对象，里面包含了a属性，值是一段文本；children属性，就是我之前在双标签体内写的文本；原来双标签体内的文本也会传入props，属性名是默认的children！也就是说单标签中给children属性赋值的话，就可以使它有自己的标签体值\n这就解释了为什么NavLink使用了单标签，而MyNavLink使用的双标签\n\n\nNavLink二次封装后，调用就变得简单明了了许多：\n&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/...&quot;&gt;...&lt;/MyNavLink&gt;  //...换成对应的属性即可\n","categories":["计算机","React"]},{"title":"Switch","url":"/Switch/","content":"路由设置好后，当我们点击链接时，它会在我们已经注册的路由中去匹配和我们点击的一致的路由来展示在页面上\n是怎么匹配的呢？\n当已经有了Home和About两个路由组件时：\n\n我们再注册一个路由组件Test：\n&lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;&lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;&lt;Route path=&quot;/home&quot; component=&#123;Test&#125; /&gt;\n\n可以看到，一个home对应了两个组件的展示，这样显然是不太合理的；页面上会怎么展示呢？\n\n它同时把两个组件都展示出来了\n路由匹配是从已注册的路由中从上到下一个个去匹配，如果一致，则展示出来，继续往下走，直到最后一个\n那么这样岂不是很浪费资源？已经匹配到我们需要的路由了，根本不需要要再继续了！\n这时就可以使用Switch来解决这个问题\n&lt;Switch&gt;    &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;    &lt;Route path=&quot;/home&quot; component=&#123;Test&#125; /&gt;&lt;/Switch&gt;\n\n引入Switch后：\n\n可以看到只显示了匹配到的第一个&#x2F;home，下面的就不会在继续了！\n","categories":["计算机","React"]},{"title":"react-redux","url":"/react-redux/","content":"ReduxRedux非Facebook官方组件，而是第三方开发，用来管理状态的组件\n\nAction：里面是一个个的函数，每个函数返回一个对象\nStroe：通过Redux里的createStore方法并传入Reducer来创建一个Store\nReducers：执行者，来更改state并返回；\n流程：\n一般组件传递指令给Action，Action会生成对应的对象，并通过dispatch传递给Store，然后在传递给Reducers这个执行者，通过Reducers的一系列操作或修改之后，返回新的state(也是对象)给Store，此时一般组件就能通过getState方法，获取新的state\n\n💡 Store像是个老板，Action和Reducers像是员工\nAction去接业务，然后交给老板Store审核，审核完毕后交给执行者Reducers去执行操作，\n完成之后，在交给老板Store验收，最后通过一个方法把成品交给客户\n\n\n\n\n//Storeimport &#123;createStore, applyMiddleware&#125; from &#x27;redux&#x27;import thunk from &#x27;redux-thunk&#x27;   //中间件用来执行异步任务import countReducer from &#x27;./count_reducer&#x27;export default createStore(countReducer, applyMiddleware(thunk))//中间件作为第二个参数//Actionimport &#123; INCREMENT, DECREMENT &#125; from &quot;./constant&quot;export const createIncrementAction = data =&gt; (&#123; type: INCREMENT, data &#125;)export const createDecrementAction = data =&gt; (&#123; type: DECREMENT, data &#125;)export const createIncrementAsyncAction = (data, time) =&gt; &#123;  return dispatch =&gt; &#123;    setTimeout(() =&gt; &#123;      dispatch(createIncrementAction(data))    &#125;, time)  &#125;&#125;\n\nReact-ReduxReact-Redux\n\n//容器组件------------------------------------------------------------------------//引入Count的UI组件import CountUI from &quot;../../components/Count&quot;//用于store和UI组件的链接import &#123; connect &#125; from &quot;react-redux&quot;//引入actionimport &#123;  createIncrementAction,  createDecrementAction,  createIncrementAsyncAction&#125; from &quot;../../redux/count_action&quot;//此函数的返回值，就作为props传递给UI组件---状态function mapStateToProps(state) &#123;  return &#123; count: state &#125;&#125;//此函数的返回值，就作为props传递给UI组件---操作状态的方法function mapDispatchToProps(dispatch) &#123;  return &#123; //返回的是一个包含多个方法的对象    increment: value =&gt; dispatch(createIncrementAction(value)),    decrement: value =&gt; dispatch(createDecrementAction(value)),    IncrementAsync: (value, time) =&gt; &#123;      dispatch(createIncrementAsyncAction(value,time))    &#125;  &#125;&#125;//暴露export default connect(mapStateToProps, mapDispatchToProps)(CountUI)//UI组件----------------------------------------------------------------------------import React, &#123; Component &#125; from &quot;react&quot;export default class Count extends Component &#123;  //加法  increment = () =&gt; &#123;    const &#123; increment &#125; = this.props    const &#123; value &#125; = this.selectNumber    increment(value * 1)  &#125;  //减法  decrement = () =&gt; &#123;    const &#123; decrement &#125; = this.props    const &#123; value &#125; = this.selectNumber    decrement(value * 1)  &#125;  //奇数加  incrementIfOdd = () =&gt; &#123;    const &#123; increment, count &#125; = this.props    const &#123; value &#125; = this.selectNumber    if (count % 2 !== 0) &#123;      increment(value * 1)    &#125;  &#125;  //异步加（延迟加）  incrementAsync = () =&gt; &#123;    const &#123; IncrementAsync &#125; = this.props    const &#123; value &#125; = this.selectNumber    IncrementAsync(value * 1, 500)  &#125;  render() &#123;    // console.log(this.props)    const &#123; count &#125; = this.props    return (      &lt;div&gt;        &lt;h2&gt;当前求和为：&#123;count&#125;&lt;/h2&gt;        &lt;select ref=&#123;c =&gt; (this.selectNumber = c)&#125;&gt;          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;        &lt;/select&gt;        &amp;nbsp;&amp;nbsp;        &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;        &amp;nbsp;        &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;        &amp;nbsp;        &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;当前和为奇数再加&lt;/button&gt;        &amp;nbsp;        &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt;        &amp;nbsp;      &lt;/div&gt;    )  &#125;&#125;\n\n\n容器组件的简写形式import &#123; connect &#125; from &quot;react-redux&quot;import CountUI from &quot;../../components/Count&quot;import &#123;  createIncrementAction,  createDecrementAction&#125; from &quot;../../redux/count_action&quot;//API层的简写方式：当需要传入mapDispatchToProps时，它可以是对象；另外mapDispatchToProps中的action可以不用dispatch来调用，react-redux会自动调用export default connect(state =&gt; (&#123; count: state &#125;), &#123;  increment: createIncrementAction,  decrement: createDecrementAction&#125;)(CountUI)\n\n给所有容器组件传入store的简单方式//入口文件中：import React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import App from &quot;./App&quot;import store from &#x27;./redux/count_store&#x27;import &#123;Provider&#125; from &#x27;react-redux&#x27;import &quot;./index.css&quot;ReactDOM.render(  &lt;React.StrictMode&gt;    &lt;Provider store=&#123;store&#125;&gt; //使用Provider，把store交给Provider后，他会交给所有容器组件      &lt;App /&gt;    &lt;/Provider&gt;  &lt;/React.StrictMode&gt;,  document.getElementById(&quot;root&quot;))\n\n合并容器组件和UI组件and整理redux目录结构import &#123; connect &#125; from &quot;react-redux&quot;import &#123;  createIncrementAction,  createDecrementAction&#125; from &quot;../../redux/count_action&quot;import React, &#123; Component &#125; from &#x27;react&#x27;import &#x27;./index.css&#x27;/* UI组件 */class Count extends Component &#123;  increment = () =&gt; &#123;    const &#123; increment &#125; = this.props    const &#123; value &#125; = this.selectedNumber    increment(value * 1)  &#125;  decrement = () =&gt; &#123;    const &#123; decrement,sum &#125; = this.props    const &#123; value &#125; = this.selectedNumber    if(sum === 0 ) return    decrement(value * 1)  &#125;    render() &#123;    const &#123; sum &#125; = this.props    return (      &lt;div className=&quot;box&quot;&gt;        &lt;h2&gt;&#123;sum&#125;&lt;/h2&gt;        &lt;select ref=&#123;e =&gt; (this.selectedNumber = e)&#125;&gt;          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;        &lt;/select&gt;        &amp;nbsp;&amp;nbsp;        &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;        &amp;nbsp;&amp;nbsp;        &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;              &lt;/div&gt;    )  &#125;&#125;/* 容器组件 *///API层的简写方式：当需要传入mapDispatchToProps时，它可以是对象；另外mapDispatchToProps中的action可以不用dispatch来调用，react-redux会自动调用export default connect(state =&gt; (&#123; sum: state &#125;), &#123;  increment: createIncrementAction,  decrement: createDecrementAction&#125;)(Count)\n\n\n组件间使用redux共享state在已经有了Count组件的基础上，在添加一个Person组件，两个组件之间可以共享state\n每添加一个需要用到redux的组件时，都需要创建对应组件的action和reducer文件\nPerson组件：\n//reducer-------------------------------------------------------------------import &#123; ADD_PERSON &#125; from &quot;../constant&quot;const initState = [&#123; id: 1, name: &quot;xiaoxin&quot;, age: 5 &#125;]export default function personReducer(preState = initState, action) &#123;  const &#123; type, data &#125; = action  switch (type) &#123;    case ADD_PERSON:      return [data, ...preState]    default:      return preState  &#125;&#125;//action------------------------------------------------------------------import &#123;ADD_PERSON&#125; from &#x27;../constant&#x27;export const createAddPersonAction = personObj =&gt; (&#123; type: ADD_PERSON,data: personObj &#125;)//index.jsximport React, &#123; Component &#125; from &quot;react&quot;import &#123; nanoid &#125; from &quot;nanoid&quot;import &#123; connect &#125; from &quot;react-redux&quot;import &#123; createAddPersonAction &#125; from &quot;../../redux/actions/person&quot;class Person extends Component &#123;  addPerson = () =&gt; &#123;    const name = this.nameNode.value    const age = this.ageNode.value    const &#123;addPerson&#125; = this.props    if(name !== &#x27;&#x27; &amp;&amp; age !== &#x27;&#x27;) &#123;      addPerson(&#123;id:nanoid(),name,age&#125;)      this.nameNode.value = &#x27;&#x27;      this.ageNode.value = &#x27;&#x27;    &#125;  &#125;  render() &#123;    const &#123; person,sum &#125; = this.props        return (      &lt;div&gt;        &lt;h1&gt;我是Person组件,上方组件求和为：&#123;sum&#125;&lt;/h1&gt;        &lt;input          ref=&#123;e =&gt; (this.nameNode = e)&#125;          type=&quot;text&quot;          placeholder=&quot;输入姓名&quot;        /&gt;        &amp;nbsp;        &lt;input          ref=&#123;e =&gt; (this.ageNode = e)&#125;          type=&quot;text&quot;          placeholder=&quot;输入年龄&quot;        /&gt;        &amp;nbsp;        &lt;button onClick=&#123;this.addPerson&#125;&gt;提交&lt;/button&gt;        &lt;ol&gt;          &#123;person.map(personObj =&gt; &#123;            return &lt;li key=&#123;personObj.id&#125;&gt;&#123;personObj.name&#125;--&#123;personObj.age&#125;&lt;/li&gt;          &#125;)&#125;        &lt;/ol&gt;      &lt;/div&gt;    )  &#125;&#125;export default connect(//注意此时这里的state不再是普通的值，而是一个对象  state =&gt; &#123;    const &#123; person,sum &#125; = state    return &#123;person, sum&#125;   &#125;,  &#123;    addPerson: createAddPersonAction  &#125;)(Person)\n\n最终效果：\n页面分为上下两个区域：Count组件和Person组件\n两个组件都互相展示了对方的state\n\n本文章参考自B站尚硅谷视频教程\n","categories":["计算机","React"]},{"title":"todo案例","url":"/todo%E6%A1%88%E4%BE%8B/","content":"本案例来自B站尚硅谷React课程-张天禹\n使用vite+react搭建脚手架\n在src中建立components文件夹，存放子组件和组件样式；各个子组件使用各自单独的文件夹\n初始化\n在App.jsx中初始化state，\nstate = &#123;todos:[  &#123;id:1,name:&#x27;吃饭&#x27;, done:true&#125;,  &#123;id:2,name:&#x27;睡觉&#x27;, done:false&#125;,  &#123;id:3,name:&#x27;写代码&#x27;, done:false&#125;]&#125;\n\n在render中使用解构赋值，拿到state中的todos；通过props传递给List组件\n List使用解构赋值接收props的值，拿到的是一个数组\n 在render中使用数组的map()方法遍历，每次返回一个，其中key使用todos中组值的ID；同时使用展开语法把todos中的每一组值都通过props传递过去\nconst &#123;todos&#125; = this.state //初始化state&lt;List todos=&#123;todos&#125;/&gt; // 传递给List组件const &#123; todos &#125; = this.props; //List组件从props中接收return (    //在render方法中使用map()  &lt;ul className=&quot;list-box&quot;&gt;    &#123;todos.map((todoObj) =&gt; &#123;      return &lt;Item key=&#123;todoObj.id&#125; &#123;...todoObj&#125;/&gt;; //使用展开语法传递每个todo项    &#125;)&#125;  &lt;/ul&gt;);\n\n 这时页面上已经初始化完成：\n\n\n\nHeader组件：【输入待办】功能因为核心state在App中，所以遵循 state在哪里，操作state的方法就在那里\n\n在App组件中创建addToDo方法，用来操作state；通过props传递给Header组件，Header组件内在input元素上绑定onKeyUp事件，此事件调用一个Header组件实例对象的方法handleKeyUp,用来处理输入事件\n\n每个todo项都有一个id字段，这个字段不能重复；所以用到了一个ID字符生成器：Nano ID\n//App.jsx组件//添加一个todoaddToDo = (todoObj) =&gt; &#123;  //获取state  const &#123; todos &#125; = this.state  //拿到todo对象后，跟原来的todos合并  const newToDos = [todoObj,...todos]  //更新state  this.setState(&#123;todos:newToDos&#125;)&#125;&lt;Header addToDo=&#123;this.addToDo&#125; /&gt; //传递props//Header.jsx组件//输入待办事件handleKeyUp = (e) =&gt; &#123;  //拿到App的传值  const &#123; addToDo &#125; = this.props;  const &#123;target, keyCode&#125; = e  //按下的不是回车键或者输入框为空则返回  if(keyCode !== 13 || target.value.trim() === &#x27;&#x27;) return  //生成唯一ID  const toDoId = nanoid()  //组成新的对象  const newToDo = &#123;id:toDoId,name:target.value,done:false&#125;  //传递给App组件  addToDo(newToDo)  //输入框置空  target.value = &#x27;&#x27;&#125;onKeyUp=&#123;this.handleKeyUp&#125; //键盘事件\n\n \n\n\nItem组件：【完成todo项目】\n在App.jsx组件内创建checkToDo方法，是属于App实例对象的方法；通过props中传递给List组件，然后在List组件内传递给Item组件\n//App.jsx组件//勾选todocheckToDo = (id,done) =&gt; &#123;  const &#123; todos &#125; = this.state  const newToDos = todos.map(todoObj =&gt; &#123;    if(todoObj.id === id) return &#123;...todoObj,done&#125;    else return todoObj  &#125;)  this.setState(&#123;todos:newToDos&#125;)&#125;&lt;List todos=&#123;todos&#125; checkToDo=&#123;this.checkToDo&#125;/&gt; //通过props传递//List组件return (  &lt;ul className=&quot;list-box&quot;&gt;    &#123;todos.map((todoObj) =&gt; &#123;      return &lt;Item key=&#123;todoObj.id&#125; &#123;...todoObj&#125; checkToDo=&#123;checkToDo&#125; /&gt;    &#125;)&#125;  &lt;/ul&gt;);\n\n在Item.jsx组件中创建handleCheckToDo方法，方法属于Item组件实例对象；方法内通过props接收到App传过来的checkToDo方法，来执行\n 还需要在input元素上绑定事件onChange\n//Item组件//处理勾选todohandleCheckToDo = (id) =&gt; &#123;  const &#123; checkToDo &#125; = this.props;  return (e) =&gt; &#123;    const &#123; checked &#125; = e.target;    checkToDo(id, checked);  &#125;;&#125;;//绑定事件&lt;input  type=&quot;checkbox&quot;  checked=&#123;done&#125;  onChange=&#123;this.handleCheckToDo(id)&#125;/&gt;\n\n 运行时报错了\n\n 后来发现绑定事件写错了🤣\n\n 最后效果是：勾选一个tudo时，state里的数据也会随之改变\n \n\n\nItem组件：【删除一个todo】\n在App组件内创建deleteToDo方法，此方法属于App组件实例对象；方法中使用数组的filter方法，过滤出没有被删除的todo，组成新数组；通过props传递此方法给List组件，接着List组件传递给Item组件\n Item组件中创建handleDelete方法，此方法属于Item组件实例对象；通过给按钮添加点击事件来执行此函数，同时要传递一个id\n//App组件deleteToDo = (id) =&gt; &#123;  //拿到state中的todos  const &#123; todos &#125; = this.state;  //使用数组的filter方法，过滤出没有被删除的todo，组成新数组  const newToDos = todos.filter((todoObj) =&gt; &#123;    return todoObj.id !== id;  &#125;);  //更新state  this.setState(&#123;todos: newToDos&#125;)&#125;;//Item组件//删除一个todohandleDelete = (id) =&gt; &#123;  //从props中拿到deleteToDo  const &#123; deleteToDo &#125; = this.props;  return () =&gt; &#123;    //执行并传递要删除的todo的id    deleteToDo(id);  &#125;;&#125;;//通过点击事件来执行&lt;button className=&quot;btn&quot; onClick=&#123;this.handleDelete(id)&#125;&gt; \n\n \n\n\nFooter组件：【全选和计数】\n在App组件中创建checkAllToDo方法，此方法属于App组件实例对象；方法接收一个done参数，标志是否勾选；利用数组的map方法，把这个done的值合并进每个todo对象中\n 把checkAllToDo方法传递给Footer组件，同时把state中的todos也传递过去\n//App组件//勾选全部todocheckAllToDo = (done) =&gt; &#123;  //拿到state中的todos  const &#123; todos &#125; = this.state;  //使用map遍历数组，并把done的值合并进todo对象  const newToDos = todos.map((todoObj) =&gt; &#123;    return &#123; ...todoObj, done &#125;;  &#125;);  //更新state  this.setState(&#123;todos: newToDos&#125;)&#125;;//传递给Footer组件&lt;Footer checkAllToDo=&#123;this.checkAllToDo&#125; todos=&#123;todos&#125; /&gt;\n\n在Footer组件中，通过props接收checkAllToDo；创建handleCheckAll方法，接收一个参数，参数是input的checked；在input上绑定onChange事件来调用handleCheckAll\n//Footer组件const &#123; todos &#125; = this.props; //接收todos//全选handleCheckAll = (e) =&gt; &#123;  //从props中拿到checkAllToDo  const &#123; checkAllToDo &#125; = this.props;  const &#123; checked &#125; = e.target;  //执行checkAllToDo并传递checked  checkAllToDo(checked);&#125;;//绑定onChange事件&lt;input  className=&quot;checkbox&quot;  type=&quot;checkbox&quot;  onChange=&#123;this.handleCheckAll&#125;  checked=&#123;countDone === allToDo &amp;&amp; countDone !== 0 ? true : false&#125;/&gt;\n\n通过props接收todos；全部todo的数量就是todos数组的长度；已完成todo的数量使用数组的reduce方法遍历数组，todo.done为true则是已完成，countDone结果就加上一\n 当然，全选按钮和计数功能是相辅相成的；当全选时，计数中完成的数量就要等于全部todo的数量；当计数全部为0时，也就是没有了todo项，则全选按钮不应该被选中\n 所以全选按钮的checked属性需要做判断来赋值；当countDone和allToDo相等并且countDone不等于0时，则全选按钮被选中，反之不被选中\n//Footer组件const &#123; todos &#125; = this.props;//已完成的todoconst countDone = todos.reduce(  (previous, todo) =&gt; previous + (todo.done ? 1 : 0),  0);//全部todoconst allToDo = todos.length;//checked属性值的判断checked=&#123;countDone === allToDo &amp;&amp; countDone !== 0 ? true : false&#125;\n\n \n\n\nFooter组件：【清除全部已完成项】\n在App组件中创建deleteAllDone方法，此方法属于App组件实例对象；deleteAllDone中先拿到state中的todos，然后使用数组方法filter，过滤出done值为false的todo项，并生成新数组；如果新数组的长度和todos的长度一致，则表明没有已完成项，就return；否则更新state\n 通过props传递给Footer组件\n//App组件//删除全部已完成deleteAllDone = () =&gt; &#123;  //拿到todos  const &#123; todos &#125; = this.state;  //过滤出done值为false的todo项  const newToDos = todos.filter((todoObj) =&gt; !todoObj.done);  if(newToDos.length === todos.length) return  //更新state  this.setState(&#123;todos: newToDos&#125;)&#125;;//传递&lt;Footer  checkAllToDo=&#123;this.checkAllToDo&#125;  todos=&#123;todos&#125;  deleteAllDone=&#123;this.deleteAllDone&#125;/&gt;\n\nFooter组件中在button上绑定点击事件，触发handDeleteAllDone方法；该方法属于Footer实例对象；handDeleteAllDone触发从props中接收到的方法deleteAllDone\n//Footer组件//删除全部已完成handDeleteAllDone = () =&gt; &#123;  const &#123; deleteAllDone &#125; = this.props;  if(window.confirm(&#x27;确定要删除全部已完成的项目么？&#x27;))&#123;    deleteAllDone();  &#125;&#125;;//绑定事件&lt;button className=&quot;btn-clear&quot; onClick=&#123;this.handDeleteAllDone&#125;&gt;\n\n \n\n\n😎todo案例完成 \n本案例来自B站尚硅谷React课程-张天禹\n","categories":["计算机","React"]},{"title":"小案例--本地播放器","url":"/%E5%B0%8F%E6%A1%88%E4%BE%8B-%E6%9C%AC%E5%9C%B0%E6%92%AD%E6%94%BE%E5%99%A8/","content":" 小案例—本地音乐播放器\n\n\n界面很简单，由于自己不喜欢用现在市场上的音乐软件，比较喜欢下载歌曲后用本地播放器听歌，加上学了React后需要案例练手所以就产生了做个自己的本地播放器。程序和实现都是很基础的。\n用到的技术就是 Vite&#x2F;React  用的是原生API，无第三方包\n预览（部署在netlify）\n功能\n导入本地文件夹\n显示歌曲列表，显示数量\n随机播放\n双击歌曲名播放\n自动下一首\n列表内搜索\n\n学到的新知识context用于组件间共享state，很轻量\n说实话一直没搞懂这个，还需要仔细看这个点\nimport &#123; createContext, useState &#125; from &quot;react&quot;export const SongsContext = createContext([])export const SongsContextProvider = (&#123; children &#125;) =&gt; &#123;  const [state, dispatch] = useState([])  const [playing, setPlaying] = useState(&quot;&quot;)  return (    &lt;SongsContext.Provider value=&#123;&#123; state, dispatch, playing, setPlaying &#125;&#125;&gt;      &#123;children&#125;    &lt;/SongsContext.Provider&gt;  )&#125;\n\n回调 callback用到的地方很多，但一直没有细想它的流程是是什么样的\nconst fn = F =&gt; &#123;  const num = 1  F(num)&#125;fn(num =&gt; &#123;  console.log(num)&#125;)\n\nfn是一个函数，接受一个参数F，函数体内是一个常量num值为1 。\n函数最后调用F并传入参数num\n调用fn时，传入一个参数（箭头函数），由于传入的参数在fn的最后被以函数形式调用并传了参数，所以箭头函数就可以接收到fn中执行F时传入的参数\n总结来说：调用fn时传入一个函数参数，在fn函数体执行完毕后，fn帮我们调用了传入的函数参数，而且还可以把fn函数体内的各种值作为参数传递给我们的函数\n解释的不是很清楚，意思是那个意思\ninput上传本案例用到了input上传文件夹\n&lt;input  id=&quot;file&quot;  type=&quot;file&quot;  hidden  webkitdirectory=&quot;true&quot;  multiple=&#123;true&#125;  onChange=&#123;handleImport&#125;/&gt;\n\n首先type属性的值要是file，是为上传文件\n\nhidden：隐藏控件\nwebkitdirectory ：上传的是文件夹类型\nmultiple：允许多文件\n\n当使用了webkitdirectory时，需要上传文件夹，文件夹内所有文件的对象会被保存到files属性中\n\naudio音频&lt;audio\tsrc=&#123;playing ? URL.createObjectURL(playing) : &quot;&quot;&#125;\tonLoadedMetadata=&#123;handleLoad&#125;\tcontrols\tonEnded=&#123;handleShuffle&#125;\tautoPlay=&#123;true&#125;\tonPlay=&#123;handlePlayRotate&#125;\tonPause=&#123;handlePauseRotate&#125;&gt;&lt;/audio&gt;\n\n\nonLoadedMetadata ： 元数据加载完成后的事件\ncontrols：控制面板\nonEnded：播放结束后的事件\nautoPlay：自动播放\nonPlay：播放开始时的事件\nonPause：播放暂停时的事件\n\nURL.createObjectURL创建一个DOMString对象，表示 File&#x2F;Blob对象\n&lt;audio\tsrc=&#123;playing ? URL.createObjectURL(playing) : &quot;&quot;&#125;&lt;/audio&gt;\n\n根据MDN文档创建出来的对象使用完毕后需要用URL.revokeObjectURL来释放资源\n","categories":["计算机","React"]},{"title":"对传入组件的props进行限制","url":"/%E5%AF%B9%E4%BC%A0%E5%85%A5%E7%BB%84%E4%BB%B6%E7%9A%84props%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6/","content":"yarn add prop-types\n\n先添加这个包\n如果在App组件内向子组件传递了props，可以在子组件中对这个props进行限制：\n//App.jsx&lt;Child sayHello=&#123;this.sayHello&#125;/&gt;//Child.jsximport PropsTypes from &#x27;prop-types&#x27; //导入static propTypes = &#123;  sayHello: PropTypes.func.isRequired //限制这个props必须是函数，而且必须传递&#125;\n\n下面是官方给出的propTypes说明：\nMyComponent.propTypes = &#123;  // 你可以将属性声明为 JS 原生类型，默认情况下  // 这些属性都是可选的。  optionalArray: PropTypes.array,  optionalBool: PropTypes.bool,  optionalFunc: PropTypes.func,  optionalNumber: PropTypes.number,  optionalObject: PropTypes.object,  optionalString: PropTypes.string,  optionalSymbol: PropTypes.symbol,  // 任何可被渲染的元素（包括数字、字符串、元素或数组）  // (或 Fragment) 也包含这些类型。  optionalNode: PropTypes.node,  // 一个 React 元素。  optionalElement: PropTypes.element,  // 一个 React 元素类型（即，MyComponent）。  optionalElementType: PropTypes.elementType,  // 你也可以声明 prop 为类的实例，这里使用  // JS 的 instanceof 操作符。  optionalMessage: PropTypes.instanceOf(Message),  // 你可以让你的 prop 只能是特定的值，指定它为  // 枚举类型。  optionalEnum: PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]),  // 一个对象可以是几种类型中的任意一个类型  optionalUnion: PropTypes.oneOfType([    PropTypes.string,    PropTypes.number,    PropTypes.instanceOf(Message)  ]),  // 可以指定一个数组由某一类型的元素组成  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  // 可以指定一个对象由某一类型的值组成  optionalObjectOf: PropTypes.objectOf(PropTypes.number),  // 可以指定一个对象由特定的类型值组成  optionalObjectWithShape: PropTypes.shape(&#123;    color: PropTypes.string,    fontSize: PropTypes.number  &#125;),  // An object with warnings on extra properties  optionalObjectWithStrictShape: PropTypes.exact(&#123;    name: PropTypes.string,    quantity: PropTypes.number  &#125;),  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保  // 这个 prop 没有被提供时，会打印警告信息。  requiredFunc: PropTypes.func.isRequired,  // 任意类型的必需数据  requiredAny: PropTypes.any.isRequired,  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。  // 请不要使用 `console.warn` 或抛出异常，因为这在 `oneOfType` 中不会起作用。  customProp: function(props, propName, componentName) &#123;    if (!/matchme/.test(props[propName])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;,  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。  // 它应该在验证失败时返回一个 Error 对象。  // 验证器将验证数组或对象中的每个值。验证器的前两个参数  // 第一个是数组或对象本身  // 第二个是他们当前的键。  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;    if (!/matchme/.test(propValue[key])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propFullName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;)&#125;;\n\n使用 PropTypes 进行类型检查 - React\n","categories":["计算机","React"]},{"title":"给你的网站加上暗黑模式","url":"/%E7%BB%99%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%8A%A0%E4%B8%8A%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/","content":" 给你的网站加上暗黑模式\n使用这个组件可以为你的网站加上暗黑模式\nyarn add react-darkreader //或者用npm安装\n\n在react中使用rc-darkreader提供的hook\nimport React from &#x27;react&#x27;;import &#123; Switch, useDarkreader &#125; from &#x27;react-darkreader&#x27;;export default () =&gt; &#123;  const [isDark, &#123; toggle &#125;] = useDarkreader(false);  return &lt;Switch checked=&#123;isDark&#125; onChange=&#123;toggle&#125; /&gt;;&#125;;\n\n之后你就会看见一个小开关：\n\n该组件来自：rc-darkreader\n","categories":["计算机","React"]},{"title":"数组方法","url":"/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"filter()接收一个回调函数，返回一个新数组，新数组中包含达到条件的元素\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.filter(item =&gt; item &gt; 10) //大于10的数，都会被放到新数组中console.log(newArr)\n\n结果：\n\nreduce()元素中的每个元素都会参与reduce参数中的回调函数的运算\n传入一个回调函数，回调函数的第一个参数是上一次回调函数执行的结果，第二个参数是目前的数组元素。(可选)传入的第二个参数作为第一次执行回调函数时，回调函数的第一个参数。\n如果第二个参数没有指定，则回调函数的第一个参数会使用数组的第一个元素，第二个参数会使用数组的第二个元素\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.reduce(  (previous,current) =&gt; previous + current,  0)console.log(newArr)\n\nreducer逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果相加（上一步的计算结果是当前元素之前所有元素的总和）——直到没有更多的元素被相加\n结果：\n\nreduce测试题[1,2,3,4].reduce((x,y) =&gt; console.log(x,y))\n\n思考：上面的代码会输出什么？\nmap()方法创建一个新数组，其结果是该数组中的每个元素是调用一次回调函数后的返回值。\nconst arr = [12,5,1,567,9,4,32,75];const newArr = arr.map((item) =&gt; item+=1)console.log(arr)console.log(newArr)\n\n使用map遍历数组，把每个元素 +1 ，组成新数组\n看结果：\n\n","categories":["计算机","JavaScript"]},{"title":"消息订阅与发布","url":"/%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/","content":"之前跟着教程做的小案例，在组件间通信时很麻烦：\n\n父组件和子组件通信：使用Props\n子组件和父组件通信：使用父组件传来的函数\n兄弟组件通信：必须把state放在父组件内，把父组件作为桥梁实现和兄弟组件的通信\n\n以前兄弟组件通信很麻烦，今天学习了新的通信方式：\n消息订阅与发布 ➡️ PubSub-js\n比如A组件需要一些数据，这些数据是从兄弟B组件那里才能拿到\n这时A组件可以订阅消息，B组件来发布消息；当B组件发布消息时，A组件就可以收到，当然不是谁都能收到，它们中间还有一个”暗号“\n看这么一个小例子：\n//App.jsxrender() &#123;    return (      &lt;div&gt;          &lt;First /&gt;          &lt;Second /&gt;      &lt;/div&gt;    )  &#125;\n\n//First.jsx    这个组件订阅export default class First extends Component &#123;  state = &#123;    book: []  &#125;  //组件挂载后订阅  componentDidMount() &#123;    //这个&#x27;hello&#x27; 就相当于&#x27;暗号&#x27;    this.token = PubSub.subscribe(&quot;hello&quot;, (msg,bookObj) =&gt; &#123;         this.setState(bookObj)    &#125;)  &#125;  //组件卸载前取消订阅   componentWillUnmount() &#123;    PubSub.unsubscribe(this.token)  &#125;  render() &#123;    const &#123; id,name,type,author &#125; = this.state.book    return (      &lt;div&gt;        &lt;ul&gt;          &lt;li&gt;&#123;id&#125;&lt;/li&gt;          &lt;li&gt;&#123;name&#125;&lt;/li&gt;          &lt;li&gt;&#123;type&#125;&lt;/li&gt;          &lt;li&gt;&#123;author&#125;&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n//Second.jsx     这个组件发布export default class Second extends Component &#123;  //点击事件函数  handleClick = () =&gt; &#123;    //发布订阅    PubSub.publish(&quot;hello&quot;, &#123;  //这个&#x27;hello&#x27; 就相当于&#x27;暗号&#x27;      book: &#123;        id: 1,        name: &quot;活着&quot;,        type: &quot;短篇小说&quot;,        author: &quot;余华&quot;      &#125;    &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n通过消息订阅和发布成功的解决了组件间通信的问题\n\n","categories":["计算机","React"]},{"title":"网络请求的返回结果","url":"/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/","content":"const axios = require(&#x27;axios&#x27;)axios.get(&#x27;http://localhost:8000/posts&#x27;).then(  response =&gt; &#123;    console.log(response)  &#125;,  error =&gt; &#123;    console.log(error.message)  &#125;)\n\n先看请求成功的返回结果：\n\n这只是一部分，下面还有…\n再看错误的：\n\n下面还有好多！\n这种情况，我们根本不能一眼看到想要的正确&#x2F;错误的信息\n所以取回结果的时候要这么写：\nconst axios = require(&#x27;axios&#x27;)axios.get(&#x27;http://localhost:8000/posts&#x27;).then(  response =&gt; &#123;    console.log(response.data)  &#125;,  error =&gt; &#123;    console.log(error.message)  &#125;)\n\n正确的消息数据保存在data里，错误的消息数据保存在message里\n看结果：\n\n\n","categories":["计算机","axios"]},{"title":"遇到问题 > useState","url":"/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98-useState/","content":"遇到问题的代码：\nconst handleInput = e =&gt; &#123;  const &#123;target, keyCode&#125; = e  if (keyCode !== 13 || target.value.trim() === &quot;&quot;) return\t//从第二次输入开始,存储的状态是空的  setItem(prev =&gt; [...prev, &#123;id: nanoid(), target.value&#125;])   // setItem([...]) //没有使用回调的方式，更新状态正常  target.value = &quot;&quot;&#125;&lt;input  type=&quot;text&quot;  className=&quot;input&quot;  placeholder=&quot;输入主题&quot;  onKeyUp=&#123;handleInput&#125;/&gt;\n\n在input绑定了事件，获取输出的值，存储到state中\n更新状态使用了回调的形式\n结果是从第二次输入开始，setItem更新后的值总是为空，不知为何。\n在setItem回调函数中target.value为空，但是在外面就不是\n使用直接更新的方式，setItem无异常\nGoogle了一圈看到了一篇博客\n其中第二个问题《useState异步回调的问题》中第二个解决方法\n虽然和我遇到的问题好像不相干，但是这个解决方法给了我灵感：\n先把target.value的值保存以下，然后在更新状态行不行呢？\nconst handleInput = e =&gt; &#123;\t//先把值保存一下  const keyCode = e.keyCode   const value = e.target.value  if (keyCode !== 13 || value.trim() === &quot;&quot;) return  setItem(prev =&gt; [...prev, &#123;id: nanoid(), value&#125;])    e.target.value = &quot;&quot;&#125;&lt;input  type=&quot;text&quot;  className=&quot;input&quot;  placeholder=&quot;输入主题&quot;  onKeyUp=&#123;handleInput&#125;/&gt;\n\n成了！\n目前还不知道是什么原理，先记录下来\n","categories":["计算机","React"]},{"title":"高阶函数_函数的柯里化","url":"/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96/","content":"高阶函数_函数的柯里化\n💡 高阶函数：如果一个函数符合下列两个规范中的任何一个，就是高阶函数\n                  1. 若A函数，接收的参数是一个函数，那么A就是高阶函数\n                  2. 若A函数，调用后的返回值依然是一个函数，那么A就是高阶函数\n函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码方式\n\n\n这里使用了上一个表单案例：\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Login extends React.Component &#123;        //初始化状态        state = &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;,        &#125;        //保存表单数据到状态中        saveFormData = (dataType) =&gt; &#123;            return (e) =&gt; &#123;                this.setState(&#123;[dataType]: e.target.value&#125;)            &#125;        &#125;        //表单提交的回调        handleSubmit = (e) =&gt; &#123;            e.preventDefault()            const &#123; username, password &#125; = this.state            alert(`你输入的用户名是：$&#123;username&#125;，你输出的密码是：$&#123;password&#125;`)        &#125;        render() &#123;            // console.log(this);               return (                &lt;form action=&quot;#&quot; onSubmit=&#123;this.handleSubmit&#125; &gt;                    用户名：&lt;input onChange=&#123;this.saveFormData(&#x27;username&#x27;)&#125; type=&quot;text&quot; name=&quot;username&quot; /&gt;                    密码：&lt;input onChange=&#123;this.saveFormData(&#x27;password&#x27;)&#125; type=&quot;password&quot; name=&quot;password&quot; /&gt;                    &lt;button &gt;登录&lt;/button&gt;                &lt;/form&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;Login /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n通过对比发现，对函数作了精简\nonChange调用的函数变成了同一个函数，不管表单需要输入多少数据，都调用一个函数来处理；调用函数时，同时传递一个参数来标明，获取到的数据类型\n通过前面的多个例子，我们发现了一个现象，在标签内调用函数时，如果加了() ，则程序会出问题，因为加了() 后，程序在一开始就会调用这个函数，onChange 就失去了效果\n那么这里为什么能使用() 传递参数呢？\n因为onChange 触发的需要是一个函数，而这里加了() 后，则变成了一个函数返回值，自然就除了BUG\n所以我们可以让里面的函数返回一个函数，那么onChange 就可以正常工作了！\n这里的saveFormData  就是一个高阶函数！\n不用柯里化的实现上面的例子，不用柯里化怎么实现呢？\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Login extends React.Component &#123;        //初始化状态        state = &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;,        &#125;        //保存表单数据到状态中        saveFormData = (dataType, e) =&gt; &#123;            this.setState(&#123; [dataType]: e.target.value&#125;)        &#125;        //表单提交的回调        handleSubmit = (e) =&gt; &#123;            e.preventDefault()            const &#123; username, password &#125; = this.state            alert(`你输入的用户名是：$&#123;username&#125;，你输出的密码是：$&#123;password&#125;`)        &#125;        render() &#123;            // console.log(this);               return (                &lt;form action=&quot;#&quot; onSubmit=&#123;this.handleSubmit&#125; &gt;                    用户名：&lt;input onChange=&#123;e =&gt; this.saveFormData(&#x27;username&#x27;, e) &#125; type=&quot;text&quot; name=&quot;username&quot; /&gt;                    密码：&lt;input onChange=&#123;e =&gt; this.saveFormData(&#x27;password&#x27;, e) &#125; type=&quot;password&quot; name=&quot;password&quot; /&gt;                    &lt;button &gt;登录&lt;/button&gt;                &lt;/form&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;Login /&gt;, document.querySelector(&#x27;#box&#x27;))&lt;/script&gt;\n\n由于onChange 只能接收函数，那我们就给他函数\n里面直接用箭头函数写；写箭头函数时，参数只有一个？括号省略！函数体只有一条语句？大括号省略！\n在这之前把saveFormData这个函数的返回值去掉，改成直接修改状态state \n我们用箭头函数直接调用saveFormData 这个函数，传进两个参数：1. 数据类型标识 2.标签值\n最后实现的功能和上次的一样！\n","categories":["计算机","React"]}]